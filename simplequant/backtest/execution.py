from abc import ABCMeta, abstractmethod
import numpy as np

from simplequant.backtest.event import FillEvent
from simplequant.backtest.exception import NotTradable
from simplequant.constant import Direction


class ExecutionHandler:
    """
    The ExecutionHandler abstract class handles the interaction
    between a set of order objects generated by a Portfolio and
    the ultimate set of Fill objects that actually occur in the
    market.
    The handlers can be used to subclass simulated brokerages
    or live brokerages, with identical interfaces. This allows
    strategies to be backtested in a very similar manner to the
    live trading engine.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def executeOrder(self, events_queue, order_event):
        """
        Takes an Order event and executes it, producing
        a Fill event that gets placed onto the Events queue.
        :param event: Contains an Event object with order information.
        """
        raise NotImplementedError("Should implement execute_order()")


class SimulatedExecutionHandler(ExecutionHandler):
    """
    The simulated execution handler simply converts all order
    objects into their equivalent fill objects automatically
    without latency, slippage or fill-ratio issues.
    This allows a straightforward "first go" test of any strategy,
    before implementation with a more sophisticated execution
    handler.
    发出的订单将会以经过滑点调整的第二天的开盘价成交。
    """

    def __init__(self, gateway, account, rate=3/10000, slippage=0.2/100):
        """
        Initialises the handler, setting the event queues
        up internally.
        :param events: The Queue of Event objects.
        """
        self.gateway = gateway
        self.account = account
        self.rate = rate  # 券商佣金，默认万分之三
        self.slippage = slippage  # 滑点，默认0.2%
        self.stamp = 0.001  # 印花税千分之一，卖出时按成交额收取
        self.transfer = 0.00002  # 过户费，买入和卖出时按成交面额（等于成交量）收取

    def executeOrder(self, events_queue, order_event):
        """
        Simply converts Order objects into Fill objects naively,
        i.e. without any latency, slippage or fill ratio problems.
        :param event: Contains an Event object with order information.
        """
        fill_event = self.generateFill(order_event)
        if fill_event.quantity > 0:
            events_queue.put((fill_event.priority, fill_event))

    def generateFill(self, order_event):

        try:
            base_price = self.gateway.getSimulatedRealTimePrice(order_event.symbol, order_event.datetime,
                                                                order_event.order_time)
        except NotTradable:  # 已进入回测最后一天，不能继续在第二天下单，或者停牌不可交易
            slippage_price = 0
            quantity = 0
            commission = 0
        else:
            if order_event.direction == Direction.LONG:
                cash = self.account.getCurrentCash()
                slippage_price = base_price * (1 + self.slippage / 2)  # 实际购买价格，还没算各种手续费
                max_quantity = np.floor(cash / (slippage_price * (1 + self.rate + self.transfer))) // 100 * 100
                target_quantity = order_event.quantity // 100 * 100
                quantity = target_quantity if target_quantity <= max_quantity else max_quantity
                commission = slippage_price * quantity * (self.rate + self.transfer)
            elif order_event.direction == Direction.SHORT:
                max_quantity = self.account.getCurrentPosition(order_event.symbol)  # 不允许卖空，当前A股有很多限制
                target_quantity = order_event.quantity // 100 * 100
                quantity = target_quantity if target_quantity <= max_quantity else max_quantity
                slippage_price = base_price * (1 - self.slippage / 2)
                commission = slippage_price * quantity * (self.rate + self.transfer + self.stamp)
            elif order_event.direction == Direction.NET:
                quantity = order_event.quantity // 100 * 100
                slippage_price = base_price * (1 - self.slippage / 2)
                commission = slippage_price * quantity * (self.rate + self.transfer + self.stamp)
            else:
                raise ValueError('订单类型只能是Direction.LONG、Direction.SHORT或Direction.NET三种类型之一')

        # 定义在if, try, for, while内的变量具有“全局”作用域，只有def, class, lambda才是局部作用于
        return FillEvent(order_event.datetime, order_event.symbol, order_event.direction,
                         slippage_price, quantity, commission, order_event.order_time)

